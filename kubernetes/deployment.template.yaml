---
#
# NAMESPACE - Defines a logical grouping of resources
#
apiVersion: v1
kind: Namespace
metadata:
  name: ${NAMESPACE}
---
#
# DEPLOYMENT - Defines the image to use, all env variables, exposed ports and resource limits
#
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${SERVICE_NAME}
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${SERVICE_NAME}
  template:
    metadata:
      labels:
        app: ${SERVICE_NAME}
    spec:
      initContainers:
        - name: init-wait-db
          image: busybox
          command: ['sh', '-c', 'for i in $(seq 1 300); do nc -zvw1 shared-database 5432 && exit 0 || sleep 3; done; exit 1']
      containers:
        - image: ${IMAGE_NAME}
          name: ${SERVICE_NAME}
          envFrom:
            - configMapRef:
                name: ${SERVICE_NAME}-config
          env:
#            Import variables from vault
            - name: S2S_KEY
              value: '${S2S_TOKEN}'
            - name: APPINSIGHTS_INSTRUMENTATIONKEY
              value: '${APPINSIGHTS_INSTRUMENTATIONKEY}'
#           Use the postgres db created for the app further down the file
            - name: POSTGRES_HOST
              value: 'shared-database'
            - name: POSTGRES_DATABASE
              value: 'emnpa'
            - name: POSTGRES_USER
              value: 'emnpa'
            - name: POSTGRES_PASSWORD
              value: 'emnpa'
#           Copy over variables from main.tf
            - name: SPRING_DATASOURCE_URL
              value: 'jdbc:postgresql://shared-database:5432/emnpa?ssl=disable'
            - name: SPRING_DATASOURCE_USERNAME
              value: 'emnpa'
            - name: SPRING_DATASOURCE_PASSWORD
              value: 'emnpa'
            - name: ENABLE_DB_MIGRATE
              value: 'true'
            - name: REFORM_SERVICE_NAME
              value: 'em-anno' # See em_anno_app_url in variables.tf
            - name: REFORM_TEAM
              value: 'evidence'
            - name: REFORM_SERVICE_TYPE
              value: 'java'
            - name: REFORM_ENVIRONMENT
              value: 'preview'
            - name: PACKAGES_NAME
              value: 'em-anno'
            - name: PACKAGES_PROJECT
              value: 'evidence'
            - name: PACKAGES_ENVIRONMENT
              value: 'preview'
            - name: ROOT_APPENDER
              value: 'JSON_CONSOLE'
            - name: JSON_CONSOLE_PRETTY_PRINT
              value: 'false'
            - name: LOG_OUTPUT
              value: 'single'
            - name: ROOT_LOGGING_LEVEL
              value: 'INFO'
            - name: LOG_LEVEL_SPRING_WEB
              value: 'INFO'
            - name: LOG_LEVEL_DM
              value: 'INFO'
            - name: SHOW_SQL
              value: 'true'
            - name: ENDPOINTS_HEALTH_SENSITIVE
              value: 'false'
            - name: ENDPOINTS_INFO_SENSITIVE
              value: 'false'
            - name: S2S_NAMES_WHITELIST
              value: 'em_api,em_gw,ccd_gw,ccd_data,sscs,divorce_document_upload,divorce_document_generator,probate_backend,jui_webapp,pui_webapp'
            - name: CASE_WORKER_ROLES
              value: 'caseworker-probate,caseworker-cmc,caseworker-sscs,caseworker-divorce'
            - name: ENABLE_IDAM_HEALTH_CHECK
              value: 'false'
            - name: ENABLE_S2S_HEALTH_CHECK
              value: 'false'
            - name: ENABLE_LIQUIBASE # This builds the postgres container
              value: 'true'
          resources:
            requests:
              memory: "1024Mi"
              cpu: "200m"
            limits:
              memory: "2048Mi"
              cpu: "2500m"
          ports:
            - containerPort: 8080 #TODO Check this is correct.
              name: http
          imagePullPolicy: Always
# TODO Pawel, should the port be written in src/main/resources/application.yaml?
---
#
# SERVICE - exposes containers internally to the cluster - enables service discovery via internal DNS
#
apiVersion: v1
kind: Service
metadata:
  name: ${SERVICE_NAME}
  namespace: ${NAMESPACE}
  labels:
    app: ${SERVICE_NAME}
spec:
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080 #TODO Check this is correct
  selector:
    app: ${SERVICE_NAME}
---
#
# INGRESS - makes it accessible from outside the cluster
#
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ${SERVICE_NAME}
  namespace: ${NAMESPACE}
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
    - host: ${SERVICE_FQDN}
      http:
        paths:
          - path: /
            backend:
              serviceName: ${SERVICE_NAME}
              servicePort: 80
---
#
# DATABASE - Create a DB to run PRs on
#
apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-database-initdb
  namespace: ${NAMESPACE}
data:
  initdb.sql: |
    CREATE USER emnpa WITH PASSWORD 'emnpa';
    CREATE DATABASE emnpa WITH OWNER = emnpa ENCODING = 'UTF-8' CONNECTION LIMIT = -1;
---
#
# DEPLOYMENT - Defines the image & port for the postgres DB
#
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shared-database
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: shared-database
  template:
    metadata:
      labels:
        app: shared-database
    spec:
      containers:
        - image: postgres:10.5-alpine
          name: shared-database
          resources:
            requests:
              memory: '256Mi'
              cpu: '200m'
            limits:
              memory: '1024Mi'
              cpu: '1000m'
          imagePullPolicy: Always
          ports:
            - containerPort: 5432
              name: postgres
          volumeMounts:
            - mountPath: /docker-entrypoint-initdb.d
              name: initdb
              readOnly: true
      volumes:
        - name: initdb
          configMap:
            name: shared-database-initdb
---
#
# SERVICE - Expose the postgres container internally to the cluster
#
apiVersion: v1
kind: Service
metadata:
  name: shared-database
  namespace: ${NAMESPACE}
  labels:
    app: shared-database
spec:
  ports:
    - port: 5432
  selector:
    app: shared-database
  clusterIP: None
